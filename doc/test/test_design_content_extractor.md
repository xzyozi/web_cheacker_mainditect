# `content_extractor` モジュール 詳細テスト設計書

## 1. 目的

`pytest`フレームワークを導入し、`content_extractor`モジュールの主要な機能に対するユニットテストおよびインテグレーションテストを整備する。これにより、コードの品質、正確性、堅牢性を担保し、将来のリファクタリングや機能追加を安全に行えるようにする。

## 2. 方針

- **テストフレームワーク:** `pytest` を使用する。非同期処理のテストには `pytest-asyncio` を利用する。
- **モック:** Playwrightや外部APIへの依存を切り離すため、`unittest.mock` を用いてモックオブジェクトを使用する。

## 3. テストケース詳細

### 3.1. `scorer.py` (ユニットテスト)

#### `_calculate_screen_occupancy_multiplier(occupancy_rate)`
- **目的:** 画面占有率に応じたスコア倍率が、ピーク値で最大になり、離れると減衰することを確認する。
- **Test Case 1: ピーク値**
    - **内容:** 占有率がピーク値(0.8)の場合。
    - **入力:** `occupancy_rate=0.8`
    - **期待値:** `1.0` (math.exp(0))
- **Test Case 2: ピークから離れた値**
    - **内容:** 占有率がピークから大きく外れた場合。
    - **入力:** `occupancy_rate=0.1`
    - **期待値:** `1.0`より大幅に低い正の値。
- **Test Case 3: ゼロ**
    - **内容:** 占有率が0の場合。
    - **入力:** `occupancy_rate=0.0`
    - **期待値:** `1.0`より大幅に低い正の値。

#### `_score_link_length(node)`
- **目的:** リンク数に応じてスコアが変動することを確認する。
- **Test Case 1: リンク数ゼロ**
    - **内容:** 本文の可能性が高い（スコア=0.1）。
    - **入力:** `DOMTreeSt(links=[])`
    - **期待値:** `0.1`
- **Test Case 2: リンク数が平均値**
    - **内容:** 最もスコアが高くなる。
    - **入力:** `DOMTreeSt(links=[""] * 6)` (MEAN=6)
    - **期待値:** `1.0`に近い値。
- **Test Case 3: リンク数が非常に多い**
    - **内容:** ナビゲーションの可能性が高い（スコアが低くなる）。
    - **入力:** `DOMTreeSt(links=[""] * 100)`
    - **期待値:** `0.0`に近い低いスコア。

#### `_score_text_length(node)`
- **目的:** テキスト長に応じてスコアが変動することを確認する。
- **Test Case 1: テキスト長ゼロ**
    - **内容:** スコアは0。
    - **入力:** `DOMTreeSt(text="")`
    - **期待値:** `0.0`
- **Test Case 2: テキスト長が平均値**
    - **内容:** 最もスコアが高くなる。
    - **入力:** `DOMTreeSt(text="a" * 50)` (MEAN=50)
    - **期待値:** `1.0`に近い値。
- **Test Case 3: テキスト長が非常に長い**
    - **内容:** スコアが低くなる。
    - **入力:** `DOMTreeSt(text="a" * 2000)`
    - **期待値:** `0.0`に近い低いスコア。

#### `calculate_depth_weight(current_depth)`
- **目的:** DOMの階層が深いほど高い重みが返されることを確認する。
- **Test Case 1: 浅い階層**
    - **入力:** `current_depth=0`
    - **期待値:** `1.0` (base_weight)
- **Test Case 2: 深い階層**
    - **入力:** `current_depth=5` (max_depth)
    - **期待値:** `4.0` (weight_factor)

#### `is_main_element(node)`
- **目的:** タグやIDから、ノードがメインコンテンツ要素のヒントを持つか判定する。
- **Test Case 1: `<main>`タグ**
    - **入力:** `DOMTreeSt(tag="main")`
    - **期待値:** `True`
- **Test Case 2: IDに"main"を含む**
    - **入力:** `DOMTreeSt(tag="div", attributes={"id": "main-content"})`
    - **期待値:** `True`
- **Test Case 3: 該当しない**
    - **入力:** `DOMTreeSt(tag="div", attributes={"id": "sub-content"})`
    - **期待値:** `False`

#### `is_valid_element(node)`
- **目的:** ノードがメインコンテンツ候補として有効か（除外タグでなく、小さすぎないか）を判定する。
- **Test Case 1: 有効なコンテナタグ**
    - **入力:** `DOMTreeSt(tag="div", rect=BoundingBox(width=100, height=100))`
    - **期待値:** `True`
- **Test Case 2: 無効なナビゲーションタグ**
    - **入力:** `DOMTreeSt(tag="nav", rect=BoundingBox(width=100, height=100))`
    - **期待値:** `False`
- **Test Case 3: 面積が小さすぎる**
    - **入力:** `DOMTreeSt(tag="div", rect=BoundingBox(width=1, height=1))`
    - **期待値:** `False`

#### `find_candidates()`
- **目的:** `MainContentScorer`がDOMツリーからメインコンテンツの候補を正しく抽出し、スコア順にソートすることを確認する。
- **Test Case 1: 候補の抽出と順序**
    - **内容:** `is_valid_element`で除外されるべきノード（`<header>`, `<footer>`, `<aside>`など）が候補に含まれず、メインコンテンツ（`<main>`）が最も高いスコアを持つことを確認する。
    - **入力:** ヘッダー、メイン、フッター、記事、段落などを含む典型的なDOMツリー構造のフィクスチャ。
    - **期待値:** 返される候補リストの最初の要素が`<main>`タグを持つノードである。

#### `score_parent_and_children()`
- **目的:** 絞り込まれた候補（とその子孫）に対して、深さを考慮したスコアリングが正しく行われることを確認する。
- **Test Case 1: 深さによるスコア再計算**
    - **内容:** ジオメトリとテキストが同じで深さだけが違う親子のノードを作成し、子のスコアが親のスコアより高くなることを確認する。
    - **入力:** 同じ `rect` と `text` を持ち、`depth` が1と2の親子ノード。
    - **期待値:** 子ノードのスコア > 親ノードのスコア。

---

### 3.2. `core.py` (インテグレーションテスト)

**目的:** `content_extractor.core.extract_main_content` が、複数のモジュール（`make_tree`, `MainContentScorer`）と連携し、最も確からしいコンテンツブロックを特定するまでの絞り込みプロセス全体を検証する。

**Test Case 1: `extract_main_content` の絞り込みループ**
- **シナリオ:**
  初期スコアリングではメインコンテンツに見えないが、子要素を再評価するとよりスコアの高い子孫が見つかる、という状況をシミュレートする。
  具体的には、最初は広いコンテナ(`div#wrapper`)が高いスコアを持つが、その子孫である `article#main-article` が真の本文であり、再スコアリングによって最終的に選択されることを確認する。

- **テストフィクスチャ (Mock `make_tree` の返り値):**
  以下のような親子関係を持つDOMツリーを準備する。各ノードのスコアは `MainContentScorer` によって初期計算されると仮定する。

  ```
  body
  └── div#wrapper (score: 80)
      ├── nav (score: 10, is_valid=False)
      └── main
          └── article#main-article (score: 70)
              └── p (score: 95)
  ```

- **モック対象の動作:**
    1.  **`make_tree`:**
        - 上記のテストフィクスチャ（DOMツリー）を返すようにモックする。
    2.  **`MainContentScorer.find_candidates`:**
        - このツリーを評価し、`div#wrapper` と `article#main-article` を候補として返す。`div#wrapper` の方がスコアが高いとする。
    3.  **`rescore_main_content_with_children`:**
        - 呼び出されるたびに、渡されたノードの子孫を評価し、スコアを更新したリストを返すようにモックする。
        - 1回目の呼び出し（対象: `div#wrapper`）: `article#main-article` を含む子リストを返し、その中で `article#main-article` のスコアが更新されて `div#wrapper` より高くなるように設定する (例: 85)。
        - 2回目の呼び出し（対象: `article#main-article`）: `p` を含む子リストを返し、`p` のスコアがさらに高くなるように設定する (例: 95)。
        - 3回目の呼び出し（対象: `p`）: 子がいないため空リスト `[]` を返す。これによりループが終了する。

- **検証ステップ:**
    1.  `extract_main_content` を呼び出す。
    2.  内部で `MainContentScorer` が実行され、最初の候補として `div#wrapper` が選択されることを確認する。
    3.  `while` ループが開始される。
    4.  1回目の `rescore_main_content_with_children` 呼び出し後、次の最有力候補が `article#main-article` になることを確認する。
    5.  2回目の呼び出し後、次の最有力候補が `p` になることを確認する。
    6.  3回目の呼び出し後、空リストが返されループが終了することを確認する。
    7.  最終的に `extract_main_content` が `p` ノードを返すことをアサートする。

- **期待値:**
  最終的に返される `final_content` オブジェクトが、最も深い階層にある `p` タグのノードと一致する。

## 4. 新規テストの追加手順

新しいテストを追加する際は、以下の手順に従います。これにより、設計と実装の同期を保ちます。

1.  **設計書の更新:**
    本ドキュメント（`doc/test/test_design_content_extractor.md`）に、テスト対象の関数と具体的なテストケース（目的、入力、期待値）を追記します。

2.  **テストコードの実装:**
    対応するテストファイル（例: `test/test_scorer.py`）に、設計書に追記したテストケースを実装します。docstringのコメントで、設計書のどのテストケースに対応するかを明記します。

3.  **テストの実行と確認:**
    プロジェクトルートで `$env:PYTHONPATH = '.'; pytest` を実行し、追加したテストを含め、すべてのテストが成功することを確認します。

## 5. テストデータと実行

- **テストデータ:** `DOMTreeSt`と`BoundingBox`を`dataclass`からインポートし、テストケースごとにオブジェクトを生成して利用する。
- **実行方法:** プロジェクトのルートディレクトリで `$env:PYTHONPATH = '.'; pytest` を実行する。

## 6. エラー処理とエッジケースの考慮

-   **目的**: 予期せぬ入力やエラー条件に対するシステムの挙動を検証し、堅牢性を高める。
-   **検討事項**:
    *   **無効な入力値**: スコアリング関数 (`_calculate_screen_occupancy_multiplier`, `_score_link_length`, `_score_text_length`) における数値の範囲外 (`occupancy_rate`が負の値や1.0超)、`None`値、不正な型 (`DOMTreeSt`以外) の入力に対するテスト。
    *   **空のデータ**: `make_tree`が空のDOMツリーや`None`を返した場合、`MainContentScorer`が候補を全く見つけられなかった場合の`extract_main_content`の挙動。
    *   **例外処理**: 特定の操作で例外が発生した場合のハンドリング（例: 外部リソースへのアクセス失敗）。

## 7. パフォーマンス要件とテストの検討

-   **目的**: 大規模なDOMツリーや複雑なWebページからのコンテンツ抽出におけるパフォーマンス特性を理解し、最適化の指針を得る。
-   **検討事項**:
    *   **測定**: 処理時間、メモリ使用量などの主要なパフォーマンスメトリクスの特定と測定方法。
    *   **シナリオ**: 非常に長いHTMLドキュメント、多数のノードを持つDOMツリー、深すぎるDOM階層など、パフォーマンスに影響を与える可能性のあるシナリオの定義。
    *   **ツール**: `pytest-benchmark`などのパフォーマンス測定ツールの導入検討。
    *   **CI/CDとの連携**: パフォーマンス回帰を早期に検出するためのCI/CDパイプラインへの統合。

## 8. 設定/定数のテスト

-   **目的**: モジュールの挙動を制御する主要な設定値や定数（例: `_score_link_length`の`MEAN`値、`calculate_depth_weight`の`max_depth`や`weight_factor`など）がシステム全体に与える影響を理解する。
-   **検討事項**:
    *   **感度分析**: 各定数を変更した場合にスコアリング結果や抽出されるコンテンツがどのように変化するかを評価するテスト。
    *   **境界値テスト**: 定数の極端な値（最大/最小）がシステムに与える影響の検証。
    *   **ドキュメント化**: これらの定数の選択理由、影響範囲、推奨値の範囲を明確にドキュメント化する。

## 9. 依存関係の明確化

-   **目的**: `content_extractor`モジュール内の各コンポーネントおよび外部ライブラリへの依存関係を明確にし、テスト戦略におけるモックの必要性を特定する。
-   **検討事項**:
    *   **内部依存**: `core.py`が`make_tree`や`MainContentScorer`に依存するように、モジュール内の関数やクラス間の依存関係の図示または記述。
    *   **外部依存**: Playwright、`dataclasses`、`math`などの外部ライブラリへの依存。PlaywrightのようなI/Oが絡む依存は`unittest.mock`で置き換える方針を再確認。
    *   **モック戦略**: どの依存をモックし、どの依存を実体としてテストするかに関する具体的なガイドライン。

## 10. テストデータの管理戦略

-   **目的**: 複雑なテストケース（特に結合テスト）に必要なテストデータを効率的に作成、管理、再利用するための方法論を確立する。
-   **検討事項**:
    *   **データ構造**: `DOMTreeSt`や`BoundingBox`オブジェクトを生成するための構造化されたアプローチ（例: ファクトリ関数、`pytest`フィクスチャ）。
    *   **外部データファイル**: 大規模なDOMツリー構造を表現するために、JSONやHTMLファイルとしてテストデータを外部化する検討。
    *   **データの匿名化**: 実際のWebサイトから取得したデータを使用する場合の個人情報保護や機密情報保護に関する配慮。
    *   **テストデータセットのバージョン管理**: テストデータがコードの変更と同期していることを保証する方法。

## 11. テストカバレッジの目標

-   **目的**: テストスイートの網羅性を評価し、主要なコードパスが適切にテストされていることを確認する。
-   **検討事項**:
    *   **目標値の設定**: 目標とするカバレッジ率（例: ステートメント、ブランチ、関数カバレッジ）。
    *   **ツール**: `coverage.py`や`pytest-cov`の導入と活用。
    *   **CI/CDへの統合**: カバレッジレポートの生成と閾値チェックをCI/CDパイプラインに組み込む。

## 12. 「メインコンテンツ」の定義

-   **目的**: `content_extractor`が特定しようとする「メインコンテンツ」の概念を明確化し、テストケースの設計および結果の評価基準を確立する。
-   **検討事項**:
    *   **基準**: メインコンテンツを構成する一般的な特性（例: 主要なテキストブロック、画像、動画、特定のHTML要素構造、画面占有率の高さ）の定義。
    *   **除外対象**: メインコンテンツではないと見なされる要素（例: ナビゲーション、広告、フッター、サイドバー）の定義。
    *   **ユースケース**: 異なるタイプのWebページ（ブログ記事、ニュースサイト、商品ページなど）におけるメインコンテンツの具体的な例。
