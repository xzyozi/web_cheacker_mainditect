# `content_extractor` モジュール 詳細テスト設計書

## 1. 目的

`pytest`フレームワークを導入し、`content_extractor`モジュールの主要な機能に対するユニットテストおよびインテグレーションテストを整備する。これにより、コードの品質、正確性、堅牢性を担保し、将来のリファクタリングや機能追加を安全に行えるようにする。

## 2. 方針

- **テストフレームワーク:** `pytest` を使用する。非同期処理のテストには `pytest-asyncio` を利用する。
- **モック:** Playwrightや外部APIへの依存を切り離すため、`unittest.mock` を用いてモックオブジェクトを使用する。

## 3. テストケース詳細

### 3.1. `scorer.py` (ユニットテスト)

#### `_calculate_screen_occupancy_multiplier(occupancy_rate)`
- **目的:** 画面占有率に応じたスコア倍率が、ピーク値で最大になり、離れると減衰することを確認する。
- **Test Case 1: ピーク値**
    - **内容:** 占有率がピーク値(0.8)の場合。
    - **入力:** `occupancy_rate=0.8`
    - **期待値:** `1.0` (math.exp(0))
- **Test Case 2: ピークから離れた値**
    - **内容:** 占有率がピークから大きく外れた場合。
    - **入力:** `occupancy_rate=0.1`
    - **期待値:** `1.0`より大幅に低い正の値。
- **Test Case 3: ゼロ**
    - **内容:** 占有率が0の場合。
    - **入力:** `occupancy_rate=0.0`
    - **期待値:** `1.0`より大幅に低い正の値。

#### `_score_link_length(node)`
- **目的:** リンク数に応じてスコアが変動することを確認する。
- **Test Case 1: リンク数ゼロ**
    - **内容:** 本文の可能性が高い（スコア=0.1）。
    - **入力:** `DOMTreeSt(links=[])`
    - **期待値:** `0.1`
- **Test Case 2: リンク数が平均値**
    - **内容:** 最もスコアが高くなる。
    - **入力:** `DOMTreeSt(links=[""] * 6)` (MEAN=6)
    - **期待値:** `1.0`に近い値。
- **Test Case 3: リンク数が非常に多い**
    - **内容:** ナビゲーションの可能性が高い（スコアが低くなる）。
    - **入力:** `DOMTreeSt(links=[""] * 100)`
    - **期待値:** `0.0`に近い低いスコア。

#### `_score_text_length(node)`
- **目的:** テキスト長に応じてスコアが変動することを確認する。
- **Test Case 1: テキスト長ゼロ**
    - **内容:** スコアは0。
    - **入力:** `DOMTreeSt(text="")`
    - **期待値:** `0.0`
- **Test Case 2: テキスト長が平均値**
    - **内容:** 最もスコアが高くなる。
    - **入力:** `DOMTreeSt(text="a" * 50)` (MEAN=50)
    - **期待値:** `1.0`に近い値。
- **Test Case 3: テキスト長が非常に長い**
    - **内容:** スコアが低くなる。
    - **入力:** `DOMTreeSt(text="a" * 2000)`
    - **期待値:** `0.0`に近い低いスコア。

#### `calculate_depth_weight(current_depth)`
- **目的:** DOMの階層が深いほど高い重みが返されることを確認する。
- **Test Case 1: 浅い階層**
    - **入力:** `current_depth=0`
    - **期待値:** `1.0` (base_weight)
- **Test Case 2: 深い階層**
    - **入力:** `current_depth=5` (max_depth)
    - **期待値:** `4.0` (weight_factor)

#### `is_main_element(node)`
- **目的:** タグやIDから、ノードがメインコンテンツ要素のヒントを持つか判定する。
- **Test Case 1: `<main>`タグ**
    - **入力:** `DOMTreeSt(tag="main")`
    - **期待値:** `True`
- **Test Case 2: IDに"main"を含む**
    - **入力:** `DOMTreeSt(tag="div", attributes={"id": "main-content"})`
    - **期待値:** `True`
- **Test Case 3: 該当しない**
    - **入力:** `DOMTreeSt(tag="div", attributes={"id": "sub-content"})`
    - **期待値:** `False`

#### `is_valid_element(node)`
- **目的:** ノードがメインコンテンツ候補として有効か（除外タグでなく、小さすぎないか）を判定する。
- **Test Case 1: 有効なコンテナタグ**
    - **入力:** `DOMTreeSt(tag="div", rect=BoundingBox(width=100, height=100))`
    - **期待値:** `True`
- **Test Case 2: 無効なナビゲーションタグ**
    - **入力:** `DOMTreeSt(tag="nav", rect=BoundingBox(width=100, height=100))`
    - **期待値:** `False`
- **Test Case 3: 面積が小さすぎる**
    - **入力:** `DOMTreeSt(tag="div", rect=BoundingBox(width=1, height=1))`
    - **期待値:** `False`

#### `find_candidates()`
- **目的:** `MainContentScorer`がDOMツリーからメインコンテンツの候補を正しく抽出し、スコア順にソートすることを確認する。
- **Test Case 1: 候補の抽出と順序**
    - **内容:** `is_valid_element`で除外されるべきノード（`<header>`, `<footer>`, `<aside>`など）が候補に含まれず、メインコンテンツ（`<main>`）が最も高いスコアを持つことを確認する。
    - **入力:** ヘッダー、メイン、フッター、記事、段落などを含む典型的なDOMツリー構造のフィクスチャ。
    - **期待値:** 返される候補リストの最初の要素が`<main>`タグを持つノードである。

#### `score_parent_and_children()`
- **目的:** 絞り込まれた候補（とその子孫）に対して、深さを考慮したスコアリングが正しく行われることを確認する。
- **Test Case 1: 深さによるスコア再計算**
    - **内容:** ジオメトリとテキストが同じで深さだけが違う親子のノードを作成し、子のスコアが親のスコアより高くなることを確認する。
    - **入力:** 同じ `rect` と `text` を持ち、`depth` が1と2の親子ノード。
    - **期待値:** 子ノードのスコア > 親ノードのスコア。

---

### 3.2. `make_tree.py` (ユニットテスト)

`make_tree.py`は、Playwrightの`Page`オブジェクトからDOMツリーを抽出し、`DOMTreeSt`オブジェクトの階層構造に変換する役割を担います。この処理は、コンテンツ抽出プロセスの基盤となるため、その正確性を保証することが重要です。

#### `make_tree(page, selector="body", wait_for_load=True, timeout=30000, debug=True)`
- **目的:** 指定されたセレクタからDOMツリーを正しく構築し、各ノードの情報を正確に抽出することを確認する。Playwrightの非同期操作とDOM解析の連携を検証する。
- **Test Case 1: 基本的なDOM構造の抽出**
    - **内容:** シンプルなHTMLコンテンツを持つページから、タグ名、ID、属性、テキスト、子要素が正確に抽出されることを確認する。
    - **入力:** モックされた`Page`オブジェクトと`ElementHandle`オブジェクト。`page.setContent()`で提供される単純なHTML文字列。
    - **期待値:** `DOMTreeSt`オブジェクトのツリー構造が、入力HTMLと一致すること。各ノードの`tag`、`id`、`attributes`、`text`、`children`が正しいこと。
- **Test Case 2: リンクの抽出**
    - **内容:** `<a>`タグとその`href`属性が正しく`links`リストに収集されることを確認する。
    - **入力:** `href`属性を持つ複数のリンクを含むHTML。
    - **期待値:** `DOMTreeSt`ノードの`links`属性に、抽出されたリンクのURLリストが（ソートされて）含まれていること。
- **Test Case 3: バウンディングボックスの抽出と要素のスキップ**
    - **内容:** `bounding_box()`が返す`rect`情報が正確に`BoundingBox`オブジェクトに変換されること、および`bounding_box()`が`None`を返す要素がツリーに含まれないことを確認する。
    - **入力:** 表示される要素と表示されない要素（`display: none`など）を含むHTML。
    - **期待値:** `DOMTreeSt`ノードの`rect`属性が正しいこと。`bounding_box()`が`None`を返した要素が結果のツリーに含まれていないこと。
- **Test Case 4: `selector`引数の機能**
    - **内容:** 特定のセレクタが指定された場合に、そのセレクタに合致する要素からのみツリーが構築されることを確認する。
    - **入力:** 複数の独立したセクションを持つHTMLと、特定のセクションを指すセレクタ。
    - **期待値:** `DOMTreeSt`のルートノードが指定されたセレクタに合致する要素であり、その子孫のみがツリーに含まれること。
- **Test Case 5: ルート要素が見つからない場合**
    - **内容:** 指定された`selector`に合致する要素がページ上に存在しない場合に、`None`が返されることを確認する。
    - **入力:** 存在しないセレクタ。
    - **期待値:** `make_tree`が`None`を返すこと。

#### `make_css_selector(properties)` (ユニットテスト)
- **目的:** 要素のプロパティから安定したCSSセレクタが正しく生成されることを確認する。
- **Test Case 1: IDを持つ要素**
    - **内容:** `id`属性が提供されている場合、IDがセレクタとして優先されることを確認する。
    - **入力:** `{'tag': 'div', 'id': 'main-content', 'attributes': {'class': 'foo'}}`
    - **期待値:** `'div#main-content'`
- **Test Case 2: クラスのみを持つ要素**
    - **内容:** `id`がなく`class`属性がある場合、クラス名がセレクタとして使用されることを確認する。
    - **入力:** `{'tag': 'p', 'attributes': {'class': 'text-center article-body'}}`
    - **期待値:** `'p.text-center.article-body'`
- **Test Case 3: IDもクラスも持たない要素**
    - **内容:** `id`も`class`もない場合、タグ名のみがセレクタとして使用されることを確認する。
    - **入力:** `{'tag': 'span'}`
    - **期待値:** `'span'`
- **Test Case 4: 属性が複雑な要素**
    - **内容:** `class`属性に複数のクラスが含まれる場合や、`id`と`class`が混在する場合でも正しくセレクタが生成されることを確認する。
    - **入力:** `{'tag': 'a', 'id': 'unique-link', 'attributes': {'class': 'button primary'}}`
    - **期待値:** `'a#unique-link'`
- **Test Case 5: 空のproperties**
    - **内容:** 必須プロパティが欠けている場合の挙動。
    - **入力:** `{'tag': ''}` または `{}`
    - **期待値:** `''` または適切なデフォルト値。

---

### 3.4. `dom_utils.py` (ユニットテスト)

`dom_utils.py`は、`DOMTreeSt`オブジェクトを操作するためのユーティリティ関数を提供します。これらの関数はコンテンツ抽出ロジックの重要な一部であるため、その正確性と堅牢性を保証するためにテストが必要です。

#### `flatten_dom_tree(node)`
- **目的:** DOMツリーを構成するすべてのノードを、ルートから子孫まで順序付けられたフラットなリストとして正しく返すことを確認する。
- **Test Case 1: 単一ノードのツリー**
    - **内容:** 子を持たない`DOMTreeSt`ノードが入力された場合、そのノードのみを含むリストが返されることを確認する。
    - **入力:** `DOMTreeSt(tag='div')`
    - **期待値:** `[DOMTreeSt(tag='div')]`
- **Test Case 2: シンプルな親子関係**
    - **内容:** 親ノードと直接の子ノードがいくつかある場合に、正しくフラット化されることを確認する。
    - **入力:** `DOMTreeSt(tag='body', children=[DOMTreeSt(tag='div'), DOMTreeSt(tag='p')])`
    - **期待値:** `[body_node, div_node, p_node]` (順序はdfs順)
- **Test Case 3: 複数階層のツリー**
    - **内容:** 複数レベルでネストされたDOMツリーが、期待される順序（深さ優先検索順）でフラット化されることを確認する。
    - **入力:** `body -> div1 -> p1, div2 -> p2` のような複雑な構造。
    - **期待値:** `[body, div1, p1, div2, p2]`

#### `rescore_main_content_with_children(main_content)`
- **目的:** 指定されたメインコンテンツ候補とその子孫ノードが、`MainContentScorer`を用いて正しく再スコアリングされ、スコアの高い順にソートされたリストとして返されることを確認する。
- **Test Case 1: 基本的な再スコアリングとソート**
    - **内容:** ダミーの`DOMTreeSt`構造とモックされた`MainContentScorer`を使用して、再スコアリングプロセスと結果のソート順が正しいことを確認する。
    - **入力:** スコアが異なるいくつかのノードを含む`DOMTreeSt`サブツリー。`MainContentScorer.score_parent_and_children`のモックは、期待されるスコアのリストを返すように設定される。
    - **期待値:** 返される`DOMTreeSt`のリストが、降順にスコア付けされていること。
- **Test Case 2: 無効な入力タイプ**
    - **内容:** `main_content`が`DOMTreeSt`型ではない場合に、`TypeError`が適切に発生することを確認する。
    - **入力:** `None`や`str`などの無効な型の`main_content`。
    - **期待値:** `TypeError`が発生すること。
- **Test Case 3: 子ノードがない場合**
    - **内容:** `main_content`ノードに子がない場合でも、正しく処理され、自身のみを含む（または空の）ソート済みリストが返されることを確認する。
    - **入力:** 子ノードがない`DOMTreeSt`。
    - **期待値:** `main_content`ノード自体を含む（または`MainContentScorer`の動作によっては空の）リストが返されること。

---

### 3.5. `playwright_helpers.py` (ユニットテスト)

`playwright_helpers.py`モジュールは、Playwrightを使用したブラウザ自動化、`robots.txt`の取得と解析、スクリーンショットの保存など、多様なユーティリティ機能を提供します。これらの機能は外部システム（ブラウザ、ネットワーク、ファイルシステム）との連携が多いため、広範なモックと非同期テストが必要です。

#### `setup_page(url, browser)`
- **目的:** Playwrightの`Page`オブジェクトを正しく初期化し、指定されたURLへ遷移し、ページの読み込み状態を適切に待機することを確認する。
- **Test Case 1: 正常なページセットアップ**
    - **内容:** `page.goto`、`page.wait_for_selector`、`page.wait_for_load_state`が期待通りに呼び出され、`Page`オブジェクトが返されることを確認する。
    - **入力:** 有効なURLとモックされた`Browser`オブジェクト。
    - **期待値:** `Page`オブジェクトが正常に返され、関連するPlaywrightメソッドが正しい引数で呼び出されること。
- **Test Case 2: `goto`または`wait_for_selector`でのタイムアウト**
    - **内容:** `page.goto`または`page.wait_for_selector`が`PlaywrightTimeoutError`を発生させた場合に、エラーが適切にログに記録され、`None`が返されることを確認する。
    - **入力:** タイムアウトを発生させるようにモックされたPlaywrightメソッド。
    - **期待値:** エラーがログに記録され、関数が`None`を返すこと。
- **Test Case 3: `wait_for_load_state`でのタイムアウト**
    - **内容:** `page.wait_for_load_state`が`PlaywrightTimeoutError`を発生させた場合に、警告がログに記録されるが、処理は続行され`Page`オブジェクトが返されることを確認する。
    - **入力:** `wait_for_load_state`がタイムアウトするようモックされたPlaywrightメソッド。
    - **期待値:** 警告がログに記録され、`Page`オブジェクトが返されること。
- **Test Case 4: その他の例外**
    - **内容:** Playwright関連以外の予期せぬ例外が発生した場合に、エラーがログに記録され、`None`が返されることを確認する。
    - **入力:** 任意の例外を発生させるようにモックされたメソッド。
    - **期待値:** エラーがログに記録され、関数が`None`を返すこと。

#### `adjust_page_view(page)`
- **目的:** ページのコンテンツに基づいてビューポートのサイズが正しく計算され、設定されること、およびページが最下部までスクロールされることを確認する。
- **Test Case 1: 正しいビューポートサイズ設定とスクロール**
    - **内容:** `page.evaluate`が正しいJavaScriptコードを実行してページの寸法を取得し、`page.set_viewport_size`がこれらの寸法で呼び出され、`window.scrollTo`が呼び出されることを確認する。
    - **入力:** モックされた`Page`オブジェクト。
    - **期待値:** `page.evaluate`と`page.set_viewport_size`、`page.wait_for_timeout`が正しい引数で呼び出され、計算された寸法が返されること。

#### `fetch_robots_txt(url)`
- **目的:** 指定されたURLから`robots.txt`の内容を非同期で取得できること、およびネットワークエラーや無効なレスポンスを適切に処理できることを確認する。
- **Test Case 1: 正常な`robots.txt`の取得**
    - **内容:** `aiohttp.ClientSession`を使用して`robots.txt`が正常にフェッチされ、内容が文字列として返されることを確認する。
    - **入力:** 有効なURLとモックされた`aiohttp`リクエスト。
    - **期待値:** `robots.txt`の内容が文字列として返されること。
- **Test Case 2: `robots.txt`が見つからない (404)**
    - **内容:** `robots.txt`のURLが404 Not Foundを返した場合に、`None`が返されることを確認する。
    - **入力:** 404を返すようにモックされた`aiohttp`リクエスト。
    - **期待値:** `None`が返されること。
- **Test Case 3: ネットワークエラー**
    - **内容:** ネットワーク接続の問題などで`aiohttp`が例外を発生させた場合に、`None`が返されることを確認する。
    - **入力:** 例外を発生させるようにモックされた`aiohttp`リクエスト。
    - **期待値:** `None`が返されること。

#### `is_scraping_allowed(robots_txt, target_path)`
- **目的:** `robots.txt`の内容を正確に解析し、指定されたパスのスクレイピングが許可されているか否かを正しく判断できることを確認する。
- **Test Case 1: 許可されているパス**
    - **内容:** `User-agent: * Disallow: /admin` のような`robots.txt`において、`/allowed/path`が許可されることを確認する。
    - **入力:** `robots.txt`の内容と、許可されるパス。
    - **期待値:** `True`が返されること。
- **Test Case 2: 禁止されているパス**
    - **内容:** `User-agent: * Disallow: /private` のような`robots.txt`において、`/private/data`が禁止されることを確認する。
    - **入力:** `robots.txt`の内容と、禁止されるパス。
    - **期待値:** `False`が返されること。
- **Test Case 3: `robots.txt`が存在しない（空の文字列）**
    - **内容:** `robots_txt`が空の場合に、すべてのパスが許可されることを確認する。
    - **入力:** 空文字列と任意のパス。
    - **期待値:** `True`が返されること。
- **Test Case 4: コメント行と空行の処理**
    - **内容:** `robots.txt`内のコメント行や空行が正しく無視されることを確認する。
    - **入力:** コメントと空行を含む`robots.txt`。
    - **期待値:** 正しい許可/不許可の判断がなされること。

#### `save_screenshot(browser, url_list, save_dir="temp", width=500, height=None)`
- **目的:** 複数のURLに対してスクリーンショットを撮影し、指定されたディレクトリに保存、リサイズできること、およびエラーやリトライを適切に処理できることを確認する。
- **Test Case 1: 正常なスクリーンショットの保存とリサイズ**
    - **内容:** 有効なURLリストに対して、各URLのスクリーンショットが撮影され、指定された幅にリサイズされ、ファイルとして保存されることを確認する。
    - **入力:** 有効なURLリストとモックされたPlaywright、`PIL.Image`、`os`モジュール。
    - **期待値:** 各URLに対して有効なファイルパスがリストとして返され、ファイルシステム操作と画像処理が正しく行われること。
- **Test Case 2: 無効なURLのスキップ**
    - **内容:** `url_list`内に無効なURLが含まれている場合に、そのURLがスキップされ、対応するリストエントリが`None`になることを確認する。
    - **入力:** 有効なURLと無効なURLの混合リスト。
    - **期待値:** 無効なURLに対して`None`が返されること。
- **Test Case 3: リトライメカニズム**
    - **内容:** `PlaywrightTimeoutError`などの一時的なエラーが発生した場合に、指定された回数だけリトライが実行され、最終的に成功するか、最大試行回数を超えて失敗することを確認する。
    - **入力:** 最初の数回はエラーを発生させ、その後成功するようにモックされたPlaywright操作。
    - **期待値:** リトライロジックが正しく実行され、最終結果（成功したパスまたは`None`）が返されること。
- **Test Case 4: 最大リトライ回数を超えた失敗**
    - **内容:** 常にエラーを発生させるようにモックされたPlaywright操作に対して、最大リトライ回数を超えた後に`None`が返されることを確認する。
    - **入力:** 常にエラーを発生させるPlaywright操作。
    - **期待値:** `None`が返されること。
- **Test Case 5: 画像リサイズ時のアスペクト比保持**
    - **内容:** `height`が指定されない場合に、`width`に基づいて元画像の正確なアスペクト比を保ってリサイズされることを確認する。
    - **入力:** 元の画像サイズと`width`。
    - **期待値:** `PIL.Image.Image.resize`が正しい`width`と計算された`height`で呼び出されること。
- **Test Case 6: ディレクトリの作成**
    - **内容:** スクリーンショット保存ディレクトリが存在しない場合に、`os.makedirs`が正しく呼び出されることを確認する。
    - **入力:** 新規の保存ディレクトリパス。
    - **期待値:** `os.makedirs(save_dir, exist_ok=True)`が呼び出されること。

#### `generate_filename(url)`
- **目的:** URLから一意でファイルシステムに適したファイル名を正しく生成できることを確認する。
- **Test Case 1: 基本的なURLからの生成**
    - **内容:** シンプルなURLからドメイン、パスの最後の部分、ハッシュを含むファイル名が生成されることを確認する。
    - **入力:** `https://example.com/some/path/page.html`
    - **期待値:** `'example_com_page_html_[hash].png'`のような形式の文字列。
- **Test Case 2: クエリパラメータを含むURL**
    - **内容:** クエリパラメータがファイル名生成に影響しないことを確認する。
    - **入力:** `https://example.com/page?param=value`
    - **期待値:** `'example_com_page_[hash].png'`のような形式の文字列。
- **Test Case 3: 特殊文字を含むURL**
    - **内容:** URL内の特殊文字（ファイルシステムで許可されないもの）が適切に処理され、有効なファイル名が生成されることを確認する。
    - **入力:** `https://example.com/path/with spaces/file!.html`
    - **期待値:** 有効なファイル名が生成されること。
- **Test Case 4: ルートURL**
    - **内容:** ドメインのみのURLが正しくファイル名に変換されることを確認する。
    - **入力:** `https://example.com`
    - **期待値:** `'example_com_index_[hash].png'`のような形式の文字列。

---

### 3.6. `core.py` (インテグレーションテスト)

**目的:** `content_extractor.core.extract_main_content` が、複数のモジュール（`make_tree`, `MainContentScorer`）と連携し、最も確からしいコンテンツブロックを特定するまでの絞り込みプロセス全体を検証する。

**Test Case 1: `extract_main_content` の絞り込みループ**
- **シナリオ:**
  初期スコアリングではメインコンテンツに見えないが、子要素を再評価するとよりスコアの高い子孫が見つかる、という状況をシミュレートする。
  具体的には、最初は広いコンテナ(`div#wrapper`)が高いスコアを持つが、その子孫である `article#main-article` が真の本文であり、再スコアリングによって最終的に選択されることを確認する。

- **テストフィクスチャ (Mock `make_tree` の返り値):**
  以下のような親子関係を持つDOMツリーを準備する。各ノードのスコアは `MainContentScorer` によって初期計算されると仮定する。

  ```
  body
  └── div#wrapper (score: 80)
      ├── nav (score: 10, is_valid=False)
      └── main
          └── article#main-article (score: 70)
              └── p (score: 95)
  ```

- **モック対象の動作:**
    1.  **`make_tree`:**
        - 上記のテストフィクスチャ（DOMツリー）を返すようにモックする。
    2.  **`MainContentScorer.find_candidates`:**
        - このツリーを評価し、`div#wrapper` と `article#main-article` を候補として返す。`div#wrapper` の方がスコアが高いとする。
    3.  **`rescore_main_content_with_children`:**
        - 呼び出されるたびに、渡されたノードの子孫を評価し、スコアを更新したリストを返すようにモックする。
        - 1回目の呼び出し（対象: `div#wrapper`）: `article#main-article` を含む子リストを返し、その中で `article#main-article` のスコアが更新されて `div#wrapper` より高くなるように設定する (例: 85)。
        - 2回目の呼び出し（対象: `article#main-article`）: `p` を含む子リストを返し、`p` のスコアがさらに高くなるように設定する (例: 95)。
        - 3回目の呼び出し（対象: `p`）: 子がいないため空リスト `[]` を返す。これによりループが終了する。

- **検証ステップ:**
    1.  `extract_main_content` を呼び出す。
    2.  内部で `MainContentScorer` が実行され、最初の候補として `div#wrapper` が選択されることを確認する。
    3.  `while` ループが開始される。
    4.  1回目の `rescore_main_content_with_children` 呼び出し後、次の最有力候補が `article#main-article` になることを確認する。
    5.  2回目の呼び出し後、次の最有力候補が `p` になることを確認する。
    6.  3回目の呼び出し後、空リストが返されループが終了することを確認する。
    7.  最終的に `extract_main_content` が `p` ノードを返すことをアサートする。

- **期待値:**
  最終的に返される `final_content` オブジェクトが、最も深い階層にある `p` タグのノードと一致する。

## 4. 新規テストの追加手順

新しいテストを追加する際は、以下の手順に従います。これにより、設計と実装の同期を保ちます。

1.  **設計書の更新:**
    本ドキュメント（`doc/test/test_design_content_extractor.md`）に、テスト対象の関数と具体的なテストケース（目的、入力、期待値）を追記します。

2.  **テストコードの実装:**
    対応するテストファイル（例: `test/test_scorer.py`）に、設計書に追記したテストケースを実装します。docstringのコメントで、設計書のどのテストケースに対応するかを明記します。

3.  **テストの実行と確認:**
    プロジェクトルートで `$env:PYTHONPATH = '.'; pytest` を実行し、追加したテストを含め、すべてのテストが成功することを確認します。

## 5. テストデータと実行

- **テストデータ:** `DOMTreeSt`と`BoundingBox`を`dataclass`からインポートし、テストケースごとにオブジェクトを生成して利用する。
- **実行方法:** プロジェクトのルートディレクトリで `$env:PYTHONPATH = '.'; pytest` を実行する。

## 6. エラー処理とエッジケースの考慮

-   **目的**: 予期せぬ入力やエラー条件に対するシステムの挙動を検証し、堅牢性を高める。
-   **検討事項**:
    *   **無効な入力値**: スコアリング関数 (`_calculate_screen_occupancy_multiplier`, `_score_link_length`, `_score_text_length`) における数値の範囲外 (`occupancy_rate`が負の値や1.0超)、`None`値、不正な型 (`DOMTreeSt`以外) の入力に対するテスト。
    *   **空のデータ**: `make_tree`が空のDOMツリーや`None`を返した場合、`MainContentScorer`が候補を全く見つけられなかった場合の`extract_main_content`の挙動。
    *   **例外処理**: 特定の操作で例外が発生した場合のハンドリング（例: 外部リソースへのアクセス失敗）。

## 7. パフォーマンス要件とテストの検討

-   **目的**: 大規模なDOMツリーや複雑なWebページからのコンテンツ抽出におけるパフォーマンス特性を理解し、最適化の指針を得る。
-   **検討事項**:
    *   **測定**: 処理時間、メモリ使用量などの主要なパフォーマンスメトリクスの特定と測定方法。
    *   **シナリオ**: 非常に長いHTMLドキュメント、多数のノードを持つDOMツリー、深すぎるDOM階層など、パフォーマンスに影響を与える可能性のあるシナリオの定義。
    *   **ツール**: `pytest-benchmark`などのパフォーマンス測定ツールの導入検討。
    *   **CI/CDとの連携**: パフォーマンス回帰を早期に検出するためのCI/CDパイプラインへの統合。

## 8. 設定/定数のテスト

-   **目的**: モジュールの挙動を制御する主要な設定値や定数（例: `_score_link_length`の`MEAN`値、`calculate_depth_weight`の`max_depth`や`weight_factor`など）がシステム全体に与える影響を理解する。
-   **検討事項**:
    *   **感度分析**: 各定数を変更した場合にスコアリング結果や抽出されるコンテンツがどのように変化するかを評価するテスト。
    *   **境界値テスト**: 定数の極端な値（最大/最小）がシステムに与える影響の検証。
    *   **ドキュメント化**: これらの定数の選択理由、影響範囲、推奨値の範囲を明確にドキュメント化する。

## 9. 依存関係の明確化

-   **目的**: `content_extractor`モジュール内の各コンポーネントおよび外部ライブラリへの依存関係を明確にし、テスト戦略におけるモックの必要性を特定する。
-   **検討事項**:
    *   **内部依存**: `core.py`が`make_tree`や`MainContentScorer`に依存するように、モジュール内の関数やクラス間の依存関係の図示または記述。
    *   **外部依存**: Playwright、`dataclasses`、`math`などの外部ライブラリへの依存。PlaywrightのようなI/Oが絡む依存は`unittest.mock`で置き換える方針を再確認。
    *   **モック戦略**: どの依存をモックし、どの依存を実体としてテストするかに関する具体的なガイドライン。

## 10. テストデータの管理戦略

-   **目的**: 複雑なテストケース（特に結合テスト）に必要なテストデータを効率的に作成、管理、再利用するための方法論を確立する。
-   **検討事項**:
    *   **データ構造**: `DOMTreeSt`や`BoundingBox`オブジェクトを生成するための構造化されたアプローチ（例: ファクトリ関数、`pytest`フィクスチャ）。
    *   **外部データファイル**: 大規模なDOMツリー構造を表現するために、JSONやHTMLファイルとしてテストデータを外部化する検討。
    *   **データの匿名化**: 実際のWebサイトから取得したデータを使用する場合の個人情報保護や機密情報保護に関する配慮。
    *   **テストデータセットのバージョン管理**: テストデータがコードの変更と同期していることを保証する方法。

## 11. テストカバレッジの目標

-   **目的**: テストスイートの網羅性を評価し、主要なコードパスが適切にテストされていることを確認する。
-   **検討事項**:
    *   **目標値の設定**: 目標とするカバレッジ率（例: ステートメント、ブランチ、関数カバレッジ）。
    *   **ツール**: `coverage.py`や`pytest-cov`の導入と活用。
    *   **CI/CDへの統合**: カバレッジレポートの生成と閾値チェックをCI/CDパイプラインに組み込む。

## 12. 「メインコンテンツ」の定義

-   **目的**: `content_extractor`が特定しようとする「メインコンテンツ」の概念を明確化し、テストケースの設計および結果の評価基準を確立する。
-   **検討事項**:
    *   **基準**: メインコンテンツを構成する一般的な特性（例: 主要なテキストブロック、画像、動画、特定のHTML要素構造、画面占有率の高さ）の定義。
    *   **除外対象**: メインコンテンツではないと見なされる要素（例: ナビゲーション、広告、フッター、サイドバー）の定義。
    *   **ユースケース**: 異なるタイプのWebページ（ブログ記事、ニュースサイト、商品ページなど）におけるメインコンテンツの具体的な例。
